# Blunt Visitor

## Overview

The visitor in Blunt is designed to interpret the code and produce the result. It traverses the Abstract Syntax Tree (AST) generated by the parser and executes the corresponding actions for each node type.

## Visitor Structure

The visitor is structured to handle various types of nodes in the AST, including variables, functions, expressions, and statements. It maintains a global scope and a scope stack to manage variable and function definitions.

## Key Components

### Visitor Initialization

The visitor is initialized with a global scope and an empty scope stack.

### Node Visiting

The visitor provides functions to visit different types of nodes in the AST, such as variable definitions, function calls, and expressions. Each visit function processes the node and performs the necessary actions, such as evaluating expressions or executing statements.

### Built-in Functions

The visitor includes built-in functions like `len`, `print`, and `println` to provide basic functionality for the language.

### Scope Management

The visitor manages scopes to handle variable and function definitions. It can add new definitions to the current scope and retrieve existing definitions.

## File Structure

- `visitor.h`: Main visitor structure and function declarations.
- `visitor_variable.h`: Functions for visiting variable-related nodes.
- `visitor_function.h`: Functions for visiting function-related nodes.
- `visitor_expression.h`: Functions for visiting expression-related nodes.
- `visitor_statement.h`: Functions for visiting statement-related nodes.

## Usage

To use the visitor, initialize it and call the `visitor_visit` function with the root node of the AST. The visitor will traverse the AST and produce the result.

```c
visitor_T *visitor = init_visitor();
AST_T *result = visitor_visit(visitor, root_node);
```

## Conclusion

The visitor in Blunt is a crucial component for interpreting the code and producing the result. It handles various types of nodes in the AST and provides built-in functions and scope management to support the language's functionality.
